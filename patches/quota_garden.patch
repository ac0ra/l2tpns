Index: cli.c
===================================================================
--- cli.c	(revision 960)
+++ cli.c	(revision 964)
@@ -440,6 +440,8 @@
 				cli_print(cli, "\tIntercepted:\tno");
 
 			cli_print(cli, "\tWalled Garden:\t%s", session[s].walled_garden ? "YES" : "no");
+                        cli_print(cli, "\tOverQuota Garden:\t%s", session[s].overquota_garden ? "YES" : "no");
+
 			{
 				int t = (session[s].throttle_in || session[s].throttle_out);
 				cli_print(cli, "\tThrottled:\t%s%s%.0d%s%s%.0d%s%s",
@@ -492,7 +494,7 @@
 	}
 
 	// Show Summary
-	cli_print(cli, "%5s %4s %-32s %-15s %s %s %s %s %10s %10s %10s %4s %-15s %s",
+	cli_print(cli, "%5s %4s %-32s %-15s %s %s %s %s %s %10s %10s %10s %4s %-15s %s",
 			"SID",
 			"TID",
 			"Username",
@@ -500,6 +502,7 @@
 			"I",
 			"T",
 			"G",
+			"O",
 			"6",
 			"opened",
 			"downloaded",
@@ -511,7 +514,7 @@
 	for (i = 1; i < MAXSESSION; i++)
 	{
 		if (!session[i].opened) continue;
-		cli_print(cli, "%5d %4d %-32s %-15s %s %s %s %s %10u %10lu %10lu %4u %-15s %s",
+		cli_print(cli, "%5d %4d %-32s %-15s %s %s %s %s %s %10u %10lu %10lu %4u %-15s %s",
 				i,
 				session[i].tunnel,
 				session[i].user[0] ? session[i].user : "*",
@@ -519,6 +522,7 @@
 				(session[i].snoop_ip && session[i].snoop_port) ? "Y" : "N",
 				(session[i].throttle_in || session[i].throttle_out) ? "Y" : "N",
 				(session[i].walled_garden) ? "Y" : "N",
+				(session[i].overquota_garden) ? "Y" : "N",
 				(session[i].ppp.ipv6cp == Opened) ? "Y" : "N",
 				abs(time_now - (unsigned long)session[i].opened),
 				(unsigned long)session[i].cout,
Index: cluster.c
===================================================================
--- cluster.c	(revision 960)
+++ cluster.c	(revision 964)
@@ -363,6 +363,24 @@
 
 }
 
+// Exactly the same as walled garden but with modified log
+int master_overquota_packet(sessionidt s, uint8_t *data, int size)
+{
+        uint8_t buf[65536];     // Vast overkill.
+        uint8_t *p = buf;
+
+        if (!config->cluster_master_address) // No election has been held yet. Just skip it.
+                return -1;
+
+        LOG(4, 0, 0, "Overquota garden packet to master (size %d)\n", size);
+
+        add_type(&p, C_GARDEN, s, data, size);
+
+        return peer_send_data(config->cluster_master_address, buf, (p-buf));
+
+}
+
+
 //
 // Send a chunk of data as a heartbeat..
 // We save it in the history buffer as we do so.
@@ -1238,6 +1256,7 @@
 	uint8_t l2tp_flags;
 	uint8_t reserved_old_snoop;
 	uint8_t walled_garden;
+	uint8_t	overquota_garden;
 	uint8_t flags1;
 	char random_vector[MAXTEL];
 	int random_vector_length;
@@ -1297,6 +1316,7 @@
 	new.snoop_ip = old->snoop_ip;
 	new.snoop_port = old->snoop_port;
 	new.walled_garden = old->walled_garden;
+	new.overquota_garden = old->overquota_garden;
 
 	memcpy(new.random_vector, old->random_vector, sizeof(new.random_vector));
 	memcpy(new.user, old->user, sizeof(new.user));
@@ -1337,11 +1357,11 @@
 	int i, type;
 	int hb_ver = more;
 
-#if HB_VERSION != 5
+#if HB_VERSION != 6 
 # error "need to update cluster_process_heartbeat()"
 #endif
 
-	// we handle versions 3 through 5
+	// we handle versions 3 through 6 
 	if (hb_ver < 3 || hb_ver > HB_VERSION) {
 		LOG(0, 0, 0, "Received a heartbeat version that I don't support (%d)!\n", hb_ver);
 		return -1; // Ignore it??
Index: overquota.c
===================================================================
--- overquota.c	(revision 0)
+++ overquota.c	(revision 964)
@@ -0,0 +1,296 @@
+#include <string.h>
+#include <malloc.h>
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include "l2tpns.h"
+#include "plugin.h"
+#include "control.h"
+
+/* walled overquota */
+
+int plugin_api_version = PLUGIN_API_VERSION;
+static struct pluginfuncs *f = 0;
+
+static int iam_master = 0;	// We're all slaves! Slaves I tell you!
+
+char *up_commands[] = {
+    "iptables -t nat -N overquota >/dev/null 2>&1",		// Create a chain that all overquotaed users will go through
+    "iptables -t nat -F overquota",
+    ". " PLUGINCONF "/build-overquota",				// Populate with site-specific DNAT rules
+    "iptables -t nat -N overquota_users >/dev/null 2>&1",		// Empty chain, users added/removed by overquota_session
+    "iptables -t nat -F overquota_users",
+    "iptables -t nat -A PREROUTING -j overquota_users",		// DNAT any users on the overquota_users chain
+    "sysctl -w net.ipv4.netfilter.ip_conntrack_max=51200000"	// lots of entries
+    	     " net.ipv4.netfilter.ip_conntrack_tcp_timeout_established=18000 >/dev/null", // 5hrs
+    NULL,
+};
+
+char *down_commands[] = {
+    "iptables -t nat -F PREROUTING",
+    "iptables -t nat -F overquota_users",
+    "iptables -t nat -X overquota_users",
+    "iptables -t nat -F overquota",
+    "iptables -t nat -X overquota",
+    "rmmod iptable_nat",	// Should also remove ip_conntrack, but
+				// doing so can take hours...  literally.
+				// If a master is re-started as a slave,
+				// either rmmod manually, or reboot.
+    NULL,
+};
+
+#define F_UNOVERQUOTA	0
+#define F_OVERQUOTA	1
+#define F_CLEANUP	2
+
+int overquota_session(sessiont *s, int flag, char *newuser);
+
+int plugin_post_auth(struct param_post_auth *data)
+{
+    // Ignore if user authentication was successful
+    // In the case of the radius Wall-Authenticated-User, vendor-supplied
+    // attribute, auth_allowed will be 1 anyway, as will be overquota_garden.
+    if (data->auth_allowed)
+	return PLUGIN_RET_OK;
+
+    f->log(1, f->get_id_by_session(data->s), data->s->tunnel,
+	"OverQuota user allowing login\n");
+
+    data->auth_allowed = 1;
+    data->s->overquota_garden = 1;
+    return PLUGIN_RET_OK;
+}
+
+int plugin_new_session(struct param_new_session *data)
+{
+    if (!iam_master)
+	return PLUGIN_RET_OK;	// Slaves don't do walled overquota processing.
+
+    if (data->s->overquota_garden)
+	overquota_session(data->s, F_OVERQUOTA, 0);
+
+    return PLUGIN_RET_OK;
+}
+
+int plugin_kill_session(struct param_new_session *data)
+{
+    if (!iam_master)
+	return PLUGIN_RET_OK;	// Slaves don't do walled overquota processing.
+
+    if (data->s->overquota_garden)
+	overquota_session(data->s, F_CLEANUP, 0);
+
+    return PLUGIN_RET_OK;
+}
+
+char *plugin_control_help[] = {
+    "  overquota USER|SID                             Put user into the overquota garden",
+    "  unoverquota SID [USER]                         Release session from overquota garden",
+    0
+};
+
+int plugin_control(struct param_control *data)
+{
+    sessionidt session;
+    sessiont *s = 0;
+    int flag;
+    char *end;
+
+    if (data->argc < 1)
+	return PLUGIN_RET_OK;
+
+    if (strcmp(data->argv[0], "overquota") && strcmp(data->argv[0], "unoverquota"))
+	return PLUGIN_RET_OK; // not for us
+
+    if (!iam_master)
+	return PLUGIN_RET_NOTMASTER;
+
+    flag = data->argv[0][0] == 'g' ? F_OVERQUOTA : F_UNOVERQUOTA;
+
+    if (data->argc < 2 || data->argc > 3 || (data->argc > 2 && flag == F_OVERQUOTA))
+    {
+	data->response = NSCTL_RES_ERR;
+	data->additional = flag == F_OVERQUOTA
+	    ? "requires username or session id"
+	    : "requires session id and optional username";
+
+	return PLUGIN_RET_STOP;
+    }
+
+    if (!(session = strtol(data->argv[1], &end, 10)) || *end)
+    {
+	if (flag)
+	    session = f->get_session_by_username(data->argv[1]);
+	else
+	    session = 0; // can't unoverquota by username
+    }
+
+    if (session)
+	s = f->get_session_by_id(session);
+
+    if (!s || !s->ip)
+    {
+	data->response = NSCTL_RES_ERR;
+	data->additional = "session not found";
+	return PLUGIN_RET_STOP;
+    }
+
+    if (s->overquota_garden == flag)
+    {
+	data->response = NSCTL_RES_ERR;
+	data->additional = flag ? "already in overquota garden" : "not in overquota garden";
+	return PLUGIN_RET_STOP;
+    }
+
+    overquota_session(s, flag, data->argc > 2 ? data->argv[2] : 0);
+    f->session_changed(session);
+
+    data->response = NSCTL_RES_OK;
+    data->additional = 0;
+
+    return PLUGIN_RET_STOP;
+}
+
+int plugin_become_master(void)
+{
+    int i;
+    iam_master = 1;	// We just became the master. Wow!
+
+    for (i = 0; up_commands[i] && *up_commands[i]; i++)
+    {
+	f->log(3, 0, 0, "Running %s\n", up_commands[i]);
+	system(up_commands[i]);
+    }
+
+    return PLUGIN_RET_OK;
+}
+
+// Called for each active session after becoming master
+int plugin_new_session_master(sessiont *s)
+{	
+    if (s->overquota_garden)
+	overquota_session(s, F_OVERQUOTA, 0);
+
+    return PLUGIN_RET_OK;
+}
+
+int overquota_session(sessiont *s, int flag, char *newuser)
+{
+    char cmd[2048];
+    sessionidt sess;
+
+    if (!s) return 0;
+    if (!s->opened) return 0;
+
+    sess = f->get_id_by_session(s);
+    if (flag == F_OVERQUOTA)
+    {
+	f->log(2, sess, s->tunnel, "OverQuota user %s (%s)\n", s->user,
+	    f->fmtaddr(htonl(s->ip), 0));
+
+	snprintf(cmd, sizeof(cmd),
+	    "iptables -t nat -A overquota_users -s %s -j overquota",
+	    f->fmtaddr(htonl(s->ip), 0));
+
+	f->log(3, sess, s->tunnel, "%s\n", cmd);
+	system(cmd);
+	s->overquota_garden = 1;
+    }
+    else
+    {
+	sessionidt other;
+	int count = 40;
+
+	// Normal User
+	f->log(2, sess, s->tunnel, "Remove Overquota for user %s (%s)\n", s->user, f->fmtaddr(htonl(s->ip), 0));
+	if (newuser)
+	{
+	    snprintf(s->user, MAXUSER, "%s", newuser);
+	    f->log(2, sess, s->tunnel, "  Setting username to %s\n", s->user);
+	}
+
+	// Kick off any duplicate usernames
+	// but make sure not to kick off ourself
+	if (s->ip && !s->die && (other = f->get_session_by_username(s->user)) &&
+	    s != f->get_session_by_id(other))
+	{
+	    f->sessionkill(other,
+		"Duplicate session when user released from overquota");
+	}
+
+	/* Clean up counters */
+	s->pin = s->pout = 0;
+	s->cin = s->cout = 0;
+	s->cin_delta = s->cout_delta = 0;
+	s->cin_wrap = s->cout_wrap = 0;
+
+	snprintf(cmd, sizeof(cmd),
+	    "iptables -t nat -D overquota_users -s %s -j overquota",
+	    f->fmtaddr(htonl(s->ip), 0));
+
+	f->log(3, sess, s->tunnel, "%s\n", cmd);
+	while (--count)
+	{
+	    int status = system(cmd);
+	    if (WEXITSTATUS(status) != 0) break;
+	}
+
+	s->overquota_garden = 0;
+
+	if (flag != F_CLEANUP)
+	{
+	    /* OK, we're up! */
+	    uint16_t r = f->radiusnew(f->get_id_by_session(s));
+	    if (r) f->radiussend(r, RADIUSSTART);
+	}
+    }
+
+    return 1;
+}
+
+int plugin_init(struct pluginfuncs *funcs)
+{
+    FILE *tables;
+    int found_nat = 0;
+
+    if (!funcs)
+	return 0;
+
+    f = funcs;
+
+    if ((tables = fopen("/proc/net/ip_tables_names", "r")))
+    {
+	char buf[1024];
+	while (fgets(buf, sizeof(buf), tables) && !found_nat)
+	    found_nat = !strcmp(buf, "nat\n");
+
+	fclose(tables);
+    }
+
+    /* master killed/crashed? */
+    if (found_nat)
+    {
+	int i;
+	for (i = 0; down_commands[i] && *down_commands[i]; i++)
+	{
+	    f->log(3, 0, 0, "Running %s\n", down_commands[i]);
+	    system(down_commands[i]);
+	}
+    }
+
+    return 1;
+}
+
+void plugin_done()
+{
+    int i;
+
+    if (!iam_master)	// Never became master. nothing to do.
+	return;
+
+    for (i = 0; down_commands[i] && *down_commands[i]; i++)
+    {
+	f->log(3, 0, 0, "Running %s\n", down_commands[i]);
+	system(down_commands[i]);
+    }
+}
Index: cluster.h
===================================================================
--- cluster.h	(revision 960)
+++ cluster.h	(revision 964)
@@ -22,7 +22,7 @@
 #define C_MASTER		15	// Tell a slave the address of the master.
 #define C_FORWARD_DAE		16	// A DAE packet for the master to handle
 
-#define HB_VERSION		5	// Protocol version number..
+#define HB_VERSION		6	// Protocol version number..
 #define HB_MAX_SEQ		(1<<30)	// Maximum sequence number. (MUST BE A POWER OF 2!)
 #define HB_HISTORY_SIZE		64	// How many old heartbeats we remember?? (Must be a factor of HB_MAX_SEQ)
 
Index: Makefile
===================================================================
--- Makefile	(revision 960)
+++ Makefile	(revision 964)
@@ -31,7 +31,7 @@
 PROGRAMS = l2tpns nsctl
 PLUGINS = appendrealm.so autosnoop.so autothrottle.so clitousername.so \
 	  editcsid.so garden.so sessionctl.so setrxspeed.so \
-	  snoopctl.so stripdomain.so throttlectl.so
+	  snoopctl.so stripdomain.so throttlectl.so overquota.so
 
 DEFINES += -DSTATISTICS
 DEFINES += -DSTAT_CALLS
@@ -130,6 +130,7 @@
 clitousername.so: clitousername.c l2tpns.h plugin.h
 editcsid.so: editcsid.c l2tpns.h plugin.h
 garden.so: garden.c l2tpns.h plugin.h control.h
+overquota.so: overquota.c l2tpns.h plugin.h control.h
 sessionctl.so: sessionctl.c l2tpns.h plugin.h control.h
 setrxspeed.so: setrxspeed.c l2tpns.h plugin.h
 snoopctl.so: snoopctl.c l2tpns.h plugin.h control.h
Index: ppp.c
===================================================================
--- ppp.c	(revision 960)
+++ ppp.c	(revision 964)
@@ -961,7 +961,7 @@
 
 	change_state(s, ipcp, Opened);
 
-	if (!(session[s].walled_garden || session[s].flags & SESSION_STARTED))
+	if (!(session[s].walled_garden || session[s].overquota_garden || session[s].flags & SESSION_STARTED))
 	{
 		uint16_t r = radiusnew(s);
 		if (r)
Index: l2tpns.c
===================================================================
--- l2tpns.c	(revision 960)
+++ l2tpns.c	(revision 964)
@@ -1184,6 +1184,14 @@
 		return;
 	}
 
+	if (sp->overquota_garden && !config->cluster_iam_master)
+        {
+                // We are overquota gardening this
+                master_overquota_packet(s, data, size);
+                return;
+        }
+
+
 	LOG(5, s, t, "Ethernet -> Tunnel (%d bytes)\n", len);
 
 	// Add on L2TP header
@@ -1293,8 +1301,15 @@
 		// We are walled-gardening this
 		master_garden_packet(s, data, size);
 		return;
-	}
+	} else if (sp->overquota_garden && !config->cluster_iam_master)
+        {
+                // We are walled-gardening this
+                master_overquota_packet(s, data, size);
+                return;
+        }
 
+
+
 	LOG(5, s, t, "Ethernet -> Tunnel (%d bytes)\n", len);
 
 	// Add on L2TP header
@@ -1563,6 +1578,7 @@
 void sessionshutdown(sessionidt s, char const *reason, int cdn_result, int cdn_error, int term_cause)
 {
 	int walled_garden = session[s].walled_garden;
+	int overquota_garden = session[s].overquota_garden;
 
 
 	CSTAT(sessionshutdown);
@@ -2719,6 +2735,12 @@
 				return;
 			}
 
+			if (session[s].overquota_garden && !config->cluster_iam_master)
+                        {
+                                master_forward_packet(buf, len, addr->sin_addr.s_addr, addr->sin_port);
+                                return;
+                        }
+
 			processipin(s, t, p, l);
 		}
 		else if (proto == PPPIPV6 && config->ipv6_prefix.s6_addr[0])
@@ -2735,6 +2757,11 @@
 				master_forward_packet(buf, len, addr->sin_addr.s_addr, addr->sin_port);
 				return;
 			}
+			if (session[s].overquota_garden && !config->cluster_iam_master)
+                        {
+                                master_forward_packet(buf, len, addr->sin_addr.s_addr, addr->sin_port);
+                                return;
+                        }
 
 			processipv6in(s, t, p, l);
 		}
@@ -4119,7 +4146,7 @@
 
 static int dump_session(FILE **f, sessiont *s)
 {
-	if (!s->opened || !s->ip || !(s->cin_delta || s->cout_delta) || !*s->user || s->walled_garden)
+	if (!s->opened || !s->ip || !(s->cin_delta || s->cout_delta) || !*s->user || s->walled_garden || s->overquota_garden)
 		return 1;
 
 	if (!*f)
@@ -4659,6 +4686,7 @@
 
 			if (config->allow_duplicate_users) continue;
 			if (session[s].walled_garden || session[i].walled_garden) continue;
+
 			if (!strcasecmp(user, session[i].user))
 				sessionkill(i, "Duplicate session for users");
 		}
Index: l2tpns.h
===================================================================
--- l2tpns.h	(revision 960)
+++ l2tpns.h	(revision 964)
@@ -276,6 +276,7 @@
 	in_addr_t snoop_ip;		// Interception destination IP
 	uint16_t snoop_port;		// Interception destination port
 	uint8_t walled_garden;		// is this session gardened?
+	uint8_t overquota_garden;	// is this session overquota?
 	uint8_t ipv6prefixlen;		// IPv6 route prefix length
 	struct in6_addr ipv6route;	// Static IPv6 route
 	char reserved_3[11];		// Space to expand structure without changing HB_VERSION
